/*  
 *  114page ~ 116page
 *  	객체 구성
 *  	  = 속성(변수) / 동작(메소드)
 *  	  = 여러개의 독립적인 단위 => 부품 => 조립
 *  	  						---	   ---
 *  							프로그램 프로그래밍
 *  	
 *  	객체를 만들 때 사용하는 키워드(설계)
 *  	-----------------------클래스
 *  	메모리에 저장후 사용
 *  	---------- 인스턴스
 *  118page
 *  	=> 객체에 대한 설계
 *  	=> 클래스의 구성요소
 *  	class ClassName
 *  	{
 *  		--------------------
 *  		멤버변수
 *  		  = 인스턴스변수 : 객체 생성시마다 메모리가 다른 공간에 저장
 *  		  = 정적변수 : 메모리 공간 1개만 생성 => 공유
 *  			=> 구분 : static
 *  					------- 공통으로 사용 메소드, 싱글턴 : 한개의 객체 생성
 *  											  => 데이터베이스 연동
 *  											  => 스프링은 모든 클래스가 싱글
 *  		  = 적용 (객체지향 => 권장) : 데이터를 보호 : 캡슐화
 *  			데이터를 은닉화 => 메소드를 이용해서 접근하는 방식
 *  			변수의 역할
 *  			  = 읽기 (메모리에서 가지고 온다)
 *  				getXxx()
 *  			  = 쓰기 (메모리 저장0
 *  				setXxx()
 *  			  = 자동 생성 => lombok
 *  			변수의 사용범위 : 프로그램 종료시 유지
 *  						  => Heap공간에 저장
 *  						  => 다른 클래스에서도 사용이 가능
 *  		--------------------
 *  		생성자 : 변수에 대한 초기화 담당, 시작과 동시에 처리 기능
 *  			=> 생략이 가능
 *  			   --------> 컴파일러에 의해 자동으로 추가
 *  						 매개변수가 없는 생성자 (디폴트 생성자)
 *  			=> 특징
 *  				1) 클래스명과 동일하다
 *  				2) 리턴형이 존재하지 않는다
 *  				** void : 리턴형 => 결과값이 없는 경우
 *  				3) 여러개의 생성자를 만들 수 있다
 *  				   ----------- 같은 이름으로 생성 => 오버로딩 지원
 *  				** 오버로딩 : 중복 메소드 생성
 *  				   => 한개의 클래스 안에서 만든다
 *  				   => 메소드명이 동일
 *  				   => 매개변수가 다르다 (갯수, 데이터형)
 *  				   => 리턴형은 관계없다
 *  				** 초기화시에는 주로 생성자를 이용한다
 *  								----- 인스턴스변수, static변수를 사용할 수 있다
 *  				** static 변수에 대한 초기화는 static{}를 이용한다
 *  				   => 초기화 블럭 : static변수만 초기화가 가능
 *  		--------------------
 *  		메소드 : 기능 설계
 *  					설정된 변수를 어떻게 사용
 *  					동작
 *  					자바의 단점 => CallBack을 만들 수 없다
 *  								--------
 *  								시스템에 의해 자동 호출
 *  								=> 사용자 정의 메소드는 반드시 호출
 *  								=> 스프링에서는 AOP
 *  			== 구성요소
 *  				리턴형 : 사용자 요청을 처리한 결과값
 *  						=> 한개만 사용이 가능
 *  						=> 기본형 / 배열 / 클래스
 *  								  ---   ---- 상세보기
 *  								  주소
 *  				메소드명 : 구분자(메소드명이 메모리주소)
 *  						=> 변수 식별자와 동일
 *  						=> 소문자로 시작한다
 *  				매개변수 : 사용한 요청한 값 => 여러개 사용이 가능
 *  						매개변수 3개 이상 =>배열/클래스 이용
 *  						=> 갯수를 모르는 경우
 *  						System.out.printf("%d,10)
 *  						System.out.printf("%d-%d,10,20)
 *  						=> 가변매개변수 => ...
 *  						(String ...s)
 *  				[접근지정어][제어어] 리턴형 메소드명(매개변수...) => 선언부
 *  				{
 *  					=> 구현부
 *  				}
 *  		--------------------
 *  	}
 *  	=> 객체지향 프로그램
 *  		장점
 *  		  코드 재사용 : 상속 / 포함
 *  		  유지 보수시에 사용이 용이
 *  		  대형 프로젝트에서 주로 사용 : 금융권 / 증권 / 공기업(국세청, 국민연금)
 *  			=> 클래스 단위로 모듈화 => 업무 분담이 용이
 *  			   회원관련 / 게시판 / 예약 / ...
 *  		단점
 *  		  처리속도가 상대적으로 느리다 => 독립적으로 사용
 *  								  -----------
 *  								  | 상속은 거의 없다
 *  								  | 인터페이스 : 연결
 *  		  => 결합성이 높다 => 클래스 수정시에 다른 클래스에 영향
 *  			 ---------- 스프링 (로드존슨)
 *  		  객체가 많으면 용량이 커질 수 있다 (메모리에 부하)
 *  		  설계시에 많은 시간이 투자
 *  		------------------------------------------
 *  		개발 => 7개월
 *  			3개월 : 요구사항 분석
 *  			1개월 : 데이터베이스 설계
 *  			1개월 : 화면 UI
 *  			2개월 : 구현 => 테스트
 *  		------------------------------------------
 *  		CBD => 컴포넌트 베이스
 *  			   ------ 만들어진 기능을 조립
 *  		=> 프로그래머 (조립) : 자바
 *  		=> 개발자 (개발) : 컴포넌트 개발
 *  
 *  		  this/this() => 
 *  		  this => 클래스 자신의 메모리 주소를 설정
 *  		  ---- 멤버변수와 지역변수가 같은 경우 구분자로 사용
 *  			   JVM => 객체 생성될 때 자동으로 주소값을 저장
 *  			   모든 멤버관련 => 메소드, 변수 앞에 반드시 this.
 *  			   최근에는 this. 생략 => 컴파일러에 의해 자동 설정
 *  
 *  			   컴파일러가 자동 처리
 *  				=> import java.lang.*;
 *  				=> 모든 클래스는 Object 상속
 *  				class A extends Object
 *  						--------------
 *  				=> 메소드 안에서 void => return 추가
 *  				=> 생성자를 사용하지 않으면 디폴트 생성자 추가
 *  				=> this.을 생략시에 자동 추가
 *  				=> 생략이 가능
 *  			this() => 자신 클래스의 생성자를 호출시에 주로 사용
 *  			------ 사용빈도는 거의 없다
 *  			= 사용위치 => 생성자 안에서 다른 생성자를 호출할 때 사용
 *  						생성자의 첫줄에 위치
 *  						=> 문법상에 오류 발생
 *  	
 *  		122page : 객체 생성과 사용
 *  		=> 객체의 생명주기 (생성 ~ 소멸)
 *  						--------- 처리 (스프링 => 클래스 관리자)
 *  		=> new이용하면 결합성 높은 프로그램
 *  		   ---- 객체 생성 방법이 있다 => 리플렉션 (클래스명만 있으면 처리가 가능)
 *  									------ 스프링 => 스프링 가능자
 *  
 *  		설계 (class작성) ===> 메모리 저장 ===> 활용 ===> 메모리 함수
 *  			class ClassName => new 생성자() === 	   null => System.gc()
 *  			{								.메소드()
 *  				변수 / 메소드 / 생성자			.변수명
 *  			}
 *  		*** 변수만 가지고 있는 경우
 *  			=> 데이터형 클래스 (사용자 정의 데이터형)
 *  				=> 관련된 데이터를 모아서 한번에 관리
 *  		*** 메소드만 가지고 있는 경우
 *  		*** 변수 + 메소드
 *  			=> 관련된 내용을 모아서 관리 (잘 묶는가?)
 *  			=> 관리 => 데이터(상태) 관리
 *  					  -------- 변수 / 배열 / 클래스 / 파일 / RDBMS
 *  							   웹 / 모바일 => 한번 전송
 *  		
 *  	=> 1) 메소드 2) 접근지정어 3) 상속 4) 포함 5) 클래스의 종류(추상클래스, 인터페이스)
 *  	=> 예외처리 => 라이브러리 (Collection, IO, SQL, NetWork)
 *  	=> 프로젝트 / 오라클 => 시작 크롤링
 *  	=> 브라우저 (HTML/CSS/JavaScript)
 *  	=> 서버연결 => JSP(1차)
 *  	=> 스프링 (2차) => 파이썬 (데이터분석), ElasticSearch
 *  	=> 개인 => 최신기술 => 취업목적
 *  	=> AWS => 리눅스 기반 => 운영체제를 빌려서 사용 (1년 무료)
 *  	=> 옵션 (MAS => Cloud => CI/CD)
 */
class A{
	void disp(int a) {
		System.out.println("disp() Call " + a);
	}
}

public class 객체지향_1 {

	public static void main(String[] args) {
		A aa = new A();
		aa.disp(100);
		A bb = new A();
		bb.disp(1000);
		/* => 123page
		 * 선언 후 저장
		 * A aa;
		 * a = new A();
		 * 
		 * 선언과 동시에 저장
		 * A aa = new A();
		 */
	}
	
}
